""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ⡀⢀ ⠄ ⣀⣀  ⡀⣀ ⢀⣀
" ⠱⠃ ⠇ ⠇⠇⠇ ⠏  ⠣⠤
"
"Appearance {{{

" Set and configure the color scheme
colorscheme moonfly
" Highlight embedded lua in .vim
let g:vimsyn_embed = 'l'
" Transparent background
"autocmd vimenter * hi! Normal ctermbg=NONE guibg=NONE
"autocmd vimenter * hi! NonText ctermbg=NONE guibg=NONE guifg=NONE ctermfg=NONE

set background=dark
set number              " Show line numbers
set relativenumber      " Relative line numbering
set showcmd             " Display partially typed command
set lazyredraw          " Do not redraw on macro/regs/untyped commands
set showmatch           " Highlight matching [{()}]
set hlsearch            " Highlight search matches
set scrolloff=0         " Scroll offset
set conceallevel=2      " Enable text conceal (for vim-markdown)
if !has('nvim')
  set signcolumn=number   " Number column also shows signs
endif

" Disable all error bells
set noerrorbells
set novisualbell
set t_vb=
set tm=500

" Make active buffer more obvious
augroup BufFocus
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * set cursorline
  autocmd WinLeave * set nocursorline
augroup END

" {{{ Transparency

"hi Normal ctermbg=NONE 
"function! AdaptColorscheme()
"  highlight clear CursorLine
"  highlight Normal ctermbg=none
"  highlight LineNr ctermbg=none
"  highlight Folded ctermbg=none
"  highlight NonText ctermbg=none
"  highlight SpecialKey ctermbg=none
"  highlight VertSplit ctermbg=none
"  highlight SignColumn ctermbg=none
"endfunction
"autocmd ColorScheme * call AdaptColorscheme()
"
"hi Normal guibg=NONE ctermbg=NONE
"hi CursorColumn cterm=NONE ctermbg=NONE ctermfg=NONE
"hi CursorLine cterm=NONE ctermbg=NONE ctermfg=NONE
"hi CursorLineNr cterm=NONE ctermbg=NONE ctermfg=NONE
"hi clear SignColumn
"highlight cursorline ctermbg=none
"highlight cursorlineNR ctermbg=none
"highlight clear LineNr
"highlight clear SignColumn
"
"set cursorline
"set noshowmode
"" Enable CursorLine
"set nocursorline
"" Default Colors for CursorLine
"hi CursorLine cterm=NONE ctermbg=NONE ctermfg=NONE
"
"" Change Color when entering Insert Mode
"autocmd InsertEnter * set nocursorline
"
"" Revert Color to default when leaving Insert Mode
"autocmd InsertLeave * set nocursorline

" }}}

" }}}

"Behavior {{{

syntax enable           " enable syntax highlighting
filetype plugin indent on " Load filetype-specific configuration
set modeline            " Read vim modeline configs
" Swap files directory
set directory=$HOME/.vim/swapfiles//
set backupdir=$HOME/.vim/swapfiles//

set nrformats="bin,hex" " define bases for <C-a> and <C-x> math operations
set history=1000        " Remember more stuff
set tabpagemax=50       " Max tab pages

" Backspace works on autoindent, line break and start of insert
set backspace=indent,eol,start
set autoindent
set wrap

set encoding=utf8       " UTF-8 as default encoding
set ffs=unix,dos,mac    " Standard file type as Unix
set autoread            " automatically read when file is changed from outside
set wildmenu            " Completion dropdown-thing
set hidden              " Hide unsaved buffers instead of closing
"set confirm             " Prompt if exiting without saving
set mouse=a             " Use mouse for all modes
set regexpengine=0      " Explicitly disable old regex engine

set incsearch           " Search as characters are entered
set ignorecase          " Ignore case
set smartcase           " Except if there is a capital letter

set splitbelow          " New split goes below
set splitright          " and to right
set foldenable          " Enable code folding
set foldnestmax=10      " Max 10 nested folds
set foldlevel=0         " Close all folds by default
set formatoptions+=j    " Delete comment character when joining commented lines
set shortmess+=c        " Do not pass messages to ins-completion-menu

" Break line joins into multiple edits
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>
"inoremap <CR> <C-G>u<CR>

" :h :mkview
set sessionoptions-=options
set viewoptions-=options

if !has('nvim')
  set completeopt=longest,menuone,popup,noselect
endif

fun! FoldText()
  let line = getline(v:foldstart)
  let line = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')  " }}}

  let offset = 16
  let space = repeat(' ', winwidth(0) - strdisplaywidth(line) - offset) 
  let lines = v:foldend-v:foldstart + 1

  return line . space . lines
endfun
set foldtext=FoldText()

" Use ripgrep when available
if executable('rg')
  set grepprg=rg\ --vimgrep
  set grepformat=%f:%l:%c:%m
endif

" }}}

"Filetype {{{

augroup filetype_settings
  autocmd!
  " set filetypes as typescriptreact, for vim-jsx-typescript
  autocmd BufNewFile,BufRead *.tsx,*.jsx set filetype=typescriptreact

  " JS/TS stuff
  autocmd FileType javascript,typescript,javascriptreact,typescriptreact,javascript.jsx,typescript.tsx
        \ command! -buffer Fmt PrettierAsync
        \ inoreabbrev <buffer> clg console.log()<LEFT>

  " Use phtml as ft for html files
  autocmd BufRead,BufNewFile *.html set ft=phtml

  " Lua stuff
  autocmd Filetype lua
        \ setlocal expandtab tabstop=4 shiftwidth=4

augroup END

" }}}

"Status line {{{

" 
set laststatus=2                " Always show statusline

let currentmode = {
      \ 'n'  : '  NORMAL ',
      \ 'i'  : '  INSERT ',
      \ 'v'  : '  VISUAL ',
      \ 'V'  : '  V·LINE ',
      \ '' : '  V·BLOCK ',
      \ 'Rv' : '  V·RPLACE ',
      \ 'R'  : '  RPLACE ',
      \ 'no' : '  NORM·OP ',
      \ 's'  : '  SELECT ',
      \ 'S'  : '  S·LINE ',
      \ '^S' : '  S·BLOCK ',
      \ 'c'  : '  COMMAND ',
      \ 'r'  : '  PROMPT ',
      \ 'rm' : '  MORE ',
      \ 'r?' : '  CONFIRM ',
      \ 'cv' : '  VIM EX ',
      \ 'ce' : '  EX ',
      \ '!'  : '  SHELL ',
      \ 't'  : '  TERMINAL ',
      \}

" |hitest.vim|

set statusline=
set statusline+=%#DiffAdd#%{currentmode[mode()]}

set statusline+=%#Cursor#
set statusline+=\ %n\             " buffer number
set statusline+=%{&paste?'\ PASTE\ ':''}
set statusline+=%{&spell?'\ SPELL\ ':''}
set statusline+=%R                " readonly flag
set statusline+=%M                " modified [+] flag
set statusline+=%#CursorLine#     " separator
set statusline+=\ %f              " file name
set statusline+=%=                " right align

set statusline+=\ %Y\ \           " file type
set statusline+=%#Folded#         " color
set statusline+=%{FugitiveHead()}
set statusline+=%#CursorLine#     " color
set statusline+=\ %3l:%-2c        " line + column
set statusline+=%#Cursor#         " color
set statusline+=%3p%%\            " percentage

" }}}

"netrw {{{

nnoremap - :Fern . -reveal=%<CR>
"let g:netrw_banner = 0          " Top banner
"let g:netrw_liststyle = 3       " Directory list view
"let g:netrw_browse_split = 0    " File open behaviour
"let g:netrw_preview = 1         " Open preview files vertically
"let g:netrw_altv = 1
"let g:netrw_winsize = 17        " Size of opened buffer

" }}}

"Key maps {{{

" Start all searches in very magic mode
nnoremap / /\v

let mapleader = " "             " Leader key
let maplocalleader = ";"        " Local leader key

" Search for selected content
fun! s:VSetSearch()
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = temp
endfun
vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR>

" Yank to clipboard
nnoremap <leader>y "+y
vnoremap <leader>y "+y
nnoremap <leader>Y gg"+yG

" Map redraw-screen to also clear search highlights
nnoremap <silent> <C-L> :nohl<CR>:mat<CR><C-L>

" Quickly edit and reload vimrc
nnoremap <leader>ev :edit $MYVIMRC<CR>
"nnoremap <leader>sv :source $MYVIMRC<CR>

" Highlight trailing whitespace
nnoremap <leader>w :match Error /\v\s+$/<CR>

" Navigate panes
nnoremap <silent> <leader>h :wincmd h<CR>
nnoremap <silent> <leader>j :wincmd j<CR>
nnoremap <silent> <leader>k :wincmd k<CR>
nnoremap <silent> <leader>l :wincmd l<CR>

" Grep for word under cursor in cwd and open matched files in quickfix window
"nnoremap <leader>g :silent execute "grep! -R " . shellescape(expand("<cWORD>")) . " ."<CR>:copen<CR>

" }}}

"Commands {{{

" Save file with elevated permissions
command W w !sudo tee % > /dev/null

" cd to directory of current file
command Fcd silent! lcd %:p:h

" :Rename current buffer
fun! s:rename_file(new_file_path)
  execute 'saveas ' . a:new_file_path
  call delete(expand('#:p'))
  bd #
endfun

command! -nargs=1 -complete=file Rename call <SID>rename_file(<f-args>)

" }}}

"Plugins {{{

" Load plugins from non-std dirs
set rtp+=~/apps/fzf
set rtp+=~/code/vim/vimkubectl

" % jump to matching xml tags, if/else/endif, etc.
packadd! matchit


let g:vim_markdown_folding_disabled = 1     " Disable vim-markdown folds by default
let g:vim_markdown_frontmatter = 1          " Highlight YAML front matter
let g:vim_markdown_conceal = 1
let g:vim_markdown_conceal_code_blocks = 1

" Vimkubectl configuration
let g:vimkubectl_command = 'oc'

" FZF configuration
let g:fzf_layout = { 'window': { 'width': 0.8, 'height': 0.7 } }
let g:fzf_action = {
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-x': 'split',
      \ 'ctrl-v': 'vsplit' }

" Open files under current dir using fzf
"nnoremap <silent> <leader>f :FZF<CR>
nnoremap <silent> <Leader>f :call fzf#run(fzf#wrap({
      \   'source':  'fd --type f',
      \   'options': '--preview ''bat --style=plain --color=always {}''',
      \ }))<CR>

" Select from open buffers using fzf
fun! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfun

fun! s:bufnumber(bufline)
  return matchstr(a:bufline, '^[ 0-9]*')
endfun

fun! s:bufopen(bufline)
  if len(a:bufline) != 2
    return
  endif
  let cmd = get({'ctrl-s': 'sbuffer',
        \ 'ctrl-v': 'vert sbuffer',
        \ 'ctrl-t': 'tabnew | buffer'},
        \ a:bufline[0], 'buffer')
  execute cmd s:bufnumber(a:bufline[1])
endfun

fun! s:bufclose(buflines)
  if len(a:buflines) == 0
    return
  endif
  for each in a:buflines
    execute 'bdelete ' . s:bufnumber(each)
  endfor
endfun

nnoremap <silent> <Leader>b :call fzf#run(fzf#wrap({
      \   'source':  reverse(<sid>buflist()),
      \   'sink*':   function('<sid>bufopen'),
      \   'options': '--expect=ctrl-t,ctrl-v,ctrl-s --delimiter \" --preview --color=always "bat --style=plain {2}"',
      \ }))<CR>

nnoremap <silent> <Leader>B :call fzf#run(fzf#wrap({
      \   'source':  reverse(<sid>buflist()),
      \   'sink*': function('<sid>bufclose'),
      \   'options': '--delimiter \" --preview --color=always "bat --style=plain {2}"'
      \ }))<CR>

" Fuzzy directory selection
fun! s:navigate(dir)
  if len(a:dir) == 0
    return
  endif
  execute 'cd ' . a:dir
  echo a:dir
endfun

nnoremap <silent> <Leader>F :call fzf#run(fzf#wrap({
      \   'source': 'fd --type d',
      \   'sink':   function('<sid>navigate'),
      \ }))<CR>

" Fuzzy text search
fun! s:openFileAtLocation(result)
  if len(a:result) == 0
    return
  endif
  let filePos = split(a:result, ':')
  exec 'edit +' . l:filePos[1] . ' ' . l:filePos[0]
endfun

nnoremap <silent> <Leader>s :call fzf#run(fzf#wrap({
      \ 'source': 'rg --line-number ''.*''',
      \ 'options': '--delimiter : --preview "bat --style=plain --color=always {1} -H {2}" --preview-window "+{2}/2"',
      \ 'sink': function('<sid>openFileAtLocation'),
      \ }))<CR>

" }}}

"LSP {{{

set rtp+=~/code/vim/LanguageClient-neovim

let g:LanguageClient_devel = 1 " Use rust debug build
let g:LanguageClient_loggingLevel = 'INFO' " Optional, use higher logging level
"let g:LanguageClient_loggingFile = expand('~/.vim/lspclient.log')

let g:LanguageClient_serverCommands = {
      \ 'css': ['css-languageserver', '--stdio'],
      \ 'scss': ['css-languageserver', '--stdio'],
      \ 'html': ['html-languageserver', '--stdio'],
      \ 'typescript': ['typescript-language-server', '--stdio'],
      \ 'typescriptreact': ['typescript-language-server', '--stdio'],
      \ 'javascript': ['typescript-language-server', '--stdio'],
      \ 'javascriptreact': ['typescript-language-server', '--stdio'],
      \ 'rust': ['rust-analyzer'],
      \ 'yaml': ['yaml-language-server', '--stdio'],
      \ 'elm': ['elm-language-server'],
      \ 'go': ['gopls'],
      \ }

"      \ 'javascript': ['yarn.lock'],
"      \ 'javascriptreact': ['yarn.lock'],
"      \ 'typescript': ['yarn.lock'],
"      \ 'typescriptreact': ['yarn.lock'],
let g:LanguageClient_rootMarkers = {
      \ 'elm': ['elm.json'],
      \ }

let g:LanguageClient_hoverPreview = 'Always'

fun SetLSPShortcuts()
  if has_key(g:LanguageClient_serverCommands, &filetype)
    set formatexpr=LanguageClient#textDocument_rangeFormatting_sync()
    set completefunc=LanguageClient#complete

    nmap <buffer> <silent> K <Plug>(lcn-hover)
    nmap <buffer> <silent> gd <Plug>(lcn-definition)
    nmap <buffer> <silent> gt <Plug>(lcn-type-definition)
    nmap <buffer> <silent> gr <Plug>(lcn-references)

    nmap <buffer> <silent> <leader>A <Plug>(lcn-code-lens-action)
    nmap <buffer> <silent> <leader>a <Plug>(lcn-code-action)
    vmap <buffer> <silent> <leader>a <Plug>(lcn-code-action)

    nmap <buffer> <silent> <leader>r <Plug>(lcn-rename)
    nmap <buffer> <silent> <leader>e <Plug>(lcn-explain-error)
    nmap <buffer> <silent> <leader>s <Plug>(lcn-symbols)
    nmap <buffer> <silent> <leader>= <Plug>(lcn-format)

    nmap <buffer> <silent> <leader>n <Plug>(lcn-diagnostics-next)
    nmap <buffer> <silent> <leader>N <Plug>(lcn-diagnostics-prev)
  endif
endfun

augroup LSP
  autocmd!
  autocmd FileType * call SetLSPShortcuts()
augroup END

" }}}

" vim: fdm=marker:et:sw=2:
