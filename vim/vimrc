""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Appearance {{{

" Set and configure the color scheme
colorscheme OceanicNext
set background=dark
set number              " Show line numbers
set relativenumber      " Relative line numbering
set showcmd             " Display partially typed command
set lazyredraw          " Do not redraw on macro/regs/untyped commands
set showmatch           " Highlight matching [{()}]
set hlsearch            " Highlight search matches
set scrolloff=0         " Scroll offset
set conceallevel=2      " Enable text conceal (for vim-markdown)
if !has('nvim')
  set signcolumn=number   " Number column also shows signs
endif

" Disable all error bells
set noerrorbells
set novisualbell
set t_vb=
set tm=500

" Make active buffer more obvious
augroup BufFocus
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * set cursorline
  autocmd WinLeave * set nocursorline
augroup END

" }}}

"Behavior {{{

syntax enable           " enable syntax highlighting
filetype plugin indent on " Load filetype-specific configuration
set modeline            " Read vim modeline configs
" Swap files directory
set directory=$HOME/.vim/swapfiles//
set backupdir=$HOME/.vim/swapfiles//

set nrformats="bin,hex" " define bases for <C-a> and <C-x> math operations
set history=1000        " Remember more stuff
set tabpagemax=50       " Max tab pages

" Backspace works on autoindent, line break and start of insert
set backspace=indent,eol,start
set autoindent
set wrap

set encoding=utf8       " UTF-8 as default encoding
set ffs=unix,dos,mac    " Standard file type as Unix
set autoread            " automatically read when file is changed from outside
set wildmenu            " Completion dropdown-thing
set hidden              " Hide unsaved buffers instead of closing
"set confirm             " Prompt if exiting without saving
set mouse=a             " Use mouse for all modes

set incsearch           " Search as characters are entered
set ignorecase          " Ignore case
set smartcase           " Except if there is a capital letter

set splitbelow          " New split goes below
set splitright          " and to right
set foldenable          " Enable code folding
set foldnestmax=10      " Max 10 nested folds
set foldlevel=0         " Close all folds by default
set formatoptions+=j    " Delete comment character when joining commented lines
set shortmess+=c        " Do not pass messages to ins-completion-menu

" Break line joins into multiple edits
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>

" :h :mkview
set sessionoptions-=options
set viewoptions-=options

if !has('nvim')
  set completeopt=longest,menuone,popup,noselect
endif

fun! FoldText()
  let line = getline(v:foldstart)
  let line = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')  " }}}

  let offset = 16
  let space = repeat(' ', winwidth(0) - strdisplaywidth(line) - offset) 
  let lines = v:foldend-v:foldstart + 1

  return line . space . lines
endfun
set foldtext=FoldText()

" }}}

"Status line {{{

" 
set laststatus=2                " Always show statusline

let currentmode = {
      \ 'n'  : '  NORMAL ',
      \ 'i'  : '  INSERT ',
      \ 'v'  : '  VISUAL ',
      \ 'V'  : '  V·LINE ',
      \ '' : '  V·BLOCK ',
      \ 'Rv' : '  V·RPLACE ',
      \ 'R'  : '  RPLACE ',
      \ 'no' : '  NORM·OP ',
      \ 's'  : '  SELECT ',
      \ 'S'  : '  S·LINE ',
      \ '^S' : '  S·BLOCK ',
      \ 'c'  : '  COMMAND ',
      \ 'r'  : '  PROMPT ',
      \ 'rm' : '  MORE ',
      \ 'r?' : '  CONFIRM ',
      \ 'cv' : '  VIM EX ',
      \ 'ce' : '  EX ',
      \ '!'  : '  SHELL ',
      \ 't'  : '  TERMINAL ',
      \}

" |hitest.vim|

set statusline=
set statusline+=%#DiffAdd#%{currentmode[mode()]}

set statusline+=%#CursorLine#    " separator
set statusline+=%#Cursor#
set statusline+=\ %n\             " buffer number
set statusline+=%{&paste?'\ PASTE\ ':''}
set statusline+=%{&spell?'\ SPELL\ ':''}
set statusline+=%R                " readonly flag
set statusline+=%M                " modified [+] flag
set statusline+=%#CursorLine#    " separator
set statusline+=\ %f              " file name
set statusline+=%=                " right align

set statusline+=%Y\ \            " file type
set statusline+=%#DiffAdd#        " color
set statusline+=%{FugitiveHead()}
set statusline+=%#CursorLine#     " color
set statusline+=\ %3l:%-2c        " line + column
set statusline+=                 " separator
set statusline+=%#Cursor#         " color
set statusline+=%3p%%\            " percentage

" }}}

"netrw {{{

let g:netrw_banner = 0          " Top banner
let g:netrw_liststyle = 3       " Directory list view
let g:netrw_browse_split = 0    " File open behaviour
let g:netrw_preview = 1         " Open preview files vertically
let g:netrw_altv = 1
"let g:netrw_winsize = 17        " Size of opened buffer

" }}}

"Key maps {{{

" Save file with elevated permissions
command W w !sudo tee % > /dev/null

" cd to directory of current file
command Fcd silent! lcd %:p:h

" Start all searches in very magic mode
nnoremap / /\v

" Search for selected content
fun! s:VSetSearch()
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = temp
endfun
vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR>

" Map redraw-screen to also clear search highlights
nnoremap <silent> <C-L> :nohl<CR>:mat<CR><C-L>

let mapleader = " "             " Leader key
let maplocalleader = ";"        " Local leader key

" Quickly edit and reload vimrc
nnoremap <leader>ev :edit $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>

" Highlight trailing whitespace
nnoremap <leader>w :match Error /\v\s+$/<CR>

" Navigate panes
nnoremap <leader>h <C-W>h
nnoremap <leader>j <C-W>j
nnoremap <leader>k <C-W>k
nnoremap <leader>l <C-W>l

" Grep for word under cursor in cwd and open matched files in quickfix window
"nnoremap <leader>g :silent execute "grep! -R " . shellescape(expand("<cWORD>")) . " ."<CR>:copen<CR>

" }}}

"Plugins {{{

" % jump to matching xml tags, if/else/endif, etc.
packadd! matchit

" Vimkubectl configuration
let g:vimkubectl_command = 'oc'

" FZF configuration
set rtp+=~/apps/fzf
let g:fzf_layout = { 'window': { 'width': 0.8, 'height': 0.7 } }
let g:fzf_action = {
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-x': 'split',
      \ 'ctrl-v': 'vsplit' }

" Open files under current dir using fzf
"nnoremap <silent> <leader>f :FZF<CR>
nnoremap <silent> <Leader>f :call fzf#run(fzf#wrap({
      \   'source':  'fd --type f',
      \   'options': '--preview ''bat --style=plain {}''',
      \ }))<CR>

" Select from open buffers using fzf
fun! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfun

fun! s:bufopen(bufline)
  if len(a:bufline) != 2
    return
  endif
  let cmd = get({'ctrl-s': 'sbuffer',
        \ 'ctrl-v': 'vert sbuffer',
        \ 'ctrl-t': 'tabnew | buffer'}, a:bufline[0], 'buffer')
  execute cmd matchstr(a:bufline[1], '^[ 0-9]*')
endfun

nnoremap <silent> <Leader>b :call fzf#run(fzf#wrap({
      \   'source':  reverse(<sid>buflist()),
      \   'sink*':   function('<sid>bufopen'),
      \   'options': '--expect=ctrl-t,ctrl-v,ctrl-s',
      \ }))<CR>

" Fuzzy directory selection
fun! s:navigate(dir)
  if len(a:dir) == 0
    return
  endif
  execute 'cd ' . a:dir
  echo a:dir
endfun

nnoremap <silent> <Leader>F :call fzf#run(fzf#wrap({
      \   'source': 'fd --type d',
      \   'sink':   function('<sid>navigate'),
      \ }))<CR>

" }}}

"Language server {{{

let g:lsp_fold_enabled = 0

if executable('typescript-language-server')
  au User lsp_setup call lsp#register_server({
        \ 'name': 'typescript-language-server',
        \ 'cmd': {server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
        \ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'tsconfig.json'))},
        \ 'whitelist': ['typescript', 'typescript.tsx'],
        \ })
  au User lsp_setup call lsp#register_server({
        \ 'name': 'javascript support using typescript-language-server',
        \ 'cmd': { server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
        \ 'root_uri': { server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_directory(lsp#utils#get_buffer_path(), '.git/..'))},
        \ 'whitelist': ['javascript', 'javascript.jsx', 'javascriptreact']
        \ })
endif

if executable('html-languageserver')
  au User lsp_setup call lsp#register_server({
        \ 'name': 'html-languageserver',
        \ 'cmd': {server_info->['html-languageserver --stdio']},
        \ 'allowlist': ['html'],
        \ })
endif

if executable('css-languageserver')
  au User lsp_setup call lsp#register_server({
        \ 'name': 'css-languageserver',
        \ 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']},
        \ 'whitelist': ['css', 'less', 'sass'],
        \ })
endif

if executable('clangd')
  au User lsp_setup call lsp#register_server({
        \ 'name': 'clangd',
        \ 'cmd': {server_info->['clangd', '-background-index']},
        \ 'allowlist': ['c', 'cpp', 'objc', 'objcpp'],
        \ })
endif

if executable('yaml-language-server')
  augroup LspYaml
    autocmd!
    autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'yaml-language-server',
          \ 'cmd': {server_info->['yaml-language-server', '--stdio']},
          \ 'allowlist': ['yaml', 'yaml.ansible'],
          \ 'workspace_config': {
          \   'yaml': {
          \     'validate': v:true,
          \     'hover': v:true,
          \     'completion': v:true,
          \     'customTags': [],
          \     'schemas': {},
          \     'schemaStore': { 'enable': v:true },
          \   }
          \ }
          \})
  augroup END
endif

fun! s:on_lsp_buffer_enabled() abort
  setlocal omnifunc=lsp#complete
  setlocal signcolumn=yes
  set foldmethod=expr
  set foldexpr=lsp#ui#vim#folding#foldexpr()
  set foldtext=lsp#ui#vim#folding#foldtext()
  if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
  nmap <buffer> K <plug>(lsp-hover)
  nmap <buffer> gd <plug>(lsp-definition)
  nmap <buffer> gr <plug>(lsp-references)
  nmap <buffer> gi <plug>(lsp-implementation)
  nmap <buffer> gt <plug>(lsp-type-definition)
  nmap <buffer> <leader>r <plug>(lsp-rename)
  nmap <buffer> <leader>a <Plug>(lsp-code-action)
  nnoremap <buffer> Fold :LspDocumentFold<CR>
endfun

augroup lsp_install
  au!
  " call s:on_lsp_buffer_enabled only for languages that has the server registered.
  autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

" }}}

" vim: fdm=marker:et:sw=2:
